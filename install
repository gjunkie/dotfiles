#!/usr/bin/env bash

# constants
readonly PROGNAME="$(basename "$0")"
readonly PROGDIR="${HOME}/Projects/dotfiles"
#readonly VERSION=$(cat "$PROGDIR/VERSION.md")
readonly TODAY=$(date +"%m-%d-%y")
readonly ARGS="$@"

# utility functions
_is_empty() {
  local var=$1
  [[ -z $var ]]
}
_is_not_empty() {
  local var=$1
  [[ -n $var ]]
}
_exists() {
  local var=$1
  [[ -e $var ]]
}
_is_file() {
  local file=$1
  [[ -f $file ]]
}
_is_dir() {
  local dir=$1
  [[ -d $dir ]]
}
_print_error() {
  local message=$1
  printf "%s⊘ Error:%s %s. Aborting!\n\n" "$(tput setaf 1)" "$(tput sgr0)" "$message"
}
_print_success() {
  local message=$1
  printf "%s✓ Success:%s\n" "$(tput setaf 2)" "$(tput sgr0) $message"
}

# options
cmdline() {
    # got this idea from here:
    # http://kirk.webfinish.com/2009/10/bash-shell-script-to-use-getopts-with-gnu-style-long-positional-parameters/
    local arg=
    for arg
    do
        local delim=""
        case "$arg" in
            #translate --gnu-long-options to -g (short options)
            --edit)         args="${args}-e ";;
            --help)         args="${args}-h ";;
            --prefix)       args="${args}-p ";;
            --test)         args="${args}-t ";;
            --version)      args="${args}-v ";;
            #pass through anything else
            *) [[ "${arg:0:1}" == "-" ]] || delim="\""
                args="${args}${delim}${arg}${delim} ";;
        esac
    done

    #Reset the positional parameters to the short options
    eval set -- "$args"

    while getopts ":ehptv" OPTION
    do
        case $OPTION in
            e)
                _edit
                exit 0
                ;;
            h)
                _print_help
                exit 0
                ;;
            p)
                _print_directory
                exit 0
                ;;
            t)
                _run_tests
                exit 0
                ;;
            v)
                _version
                exit 0
                ;;
            \?)
                _is_not_valid_option "-$OPTARG"
                usage
                exit 1
                ;;
        esac
    done

    return 0
}

_install_formula() {
    local formula=$1
    # Test whether a Homebrew formula is already installed
    if ! brew list "$formula" &> /dev/null; then
        brew install "$formula"
    fi
}

_bulk_install() {
    local file=$1
    local type=$2
    local apps
    local oifs=$IFS

    # set the separator to a carriage return & a new line break
    IFS=$'\r\n'
    # read in passed-in file and store as an array
    apps=($(cat "${file}"))
    #while IFS= read -r line; do echo "$line"; done < $file
    #mapfile -t myArray < $file
    #echo $myArray
    #echo $apps

    shopt -s globstar nullglob
    array=( **/*"$file"* )
    echo $array

    for index in ${apps[*]}
    do
	case $type in
	    homebrew)
		_install_formula "${apps[index]}"
		;;
	    #node)
		#_install_package "${apps[index]}"
		#;;
	    #ruby)
		#_install_gem "${apps[index]}"
		#;;
	    #*)
		#_symlink_file "${apps[index]}"
		#;;
	esac
    done

    IFS=$oifs
}

install_formulae() {
    # Updating Homebrew
    #brew update

    # Upgrade Homebrew formulaes
    #brew upgrade

    # Install Homebrew formulae
    # here check the hash as well
    brews="${PROGDIR}/opt/homebrew"
    echo $brews

    #old_brew="$(cat "${PROGDIR}"/var/homebrew)"
    new_brew="$(md5 "${brews}" | cut -d ' ' -f 4)"
    #if [[ $new_brew != "$old_brew" ]]; then
    _bulk_install "$brews" 'homebrew'
    #fi

    brew cleanup

    [[ $? ]] \
    && _print_success "Homebrew updated, all formulae upgraded, new formulae installed"
}

# program functions
_error_out() {
    _print_error "No $PROGDIR found!"
    printf 'Run the installer <%shttps://github.com/chrisopedia/dotfiles#how-to-install%s>\n' "$(tput smul)" "$(tput rmul)"
    exit 1
}
_require_prog() {
  local prog=$1
  local msg=$2
  local url=$3
  type -P "$prog" >/dev/null || {
    print_error "$msg"
    echo "Download it at $url"
    exit 2
  }
}

install_software() {
  echo "Do you wish to install xcode-select?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_xcode; break;;
    No ) break;;
    esac
  done

  echo "Do you wish to install Homebrew?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_homebrew; break;;
    No ) break;;
    esac
  done

  echo "Do you wish to install Homebrew Cask?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_homebrew_cask; break;;
    No ) break;;
    esac
  done

  echo "Do you wish to install npm?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_npm; break;;
    No ) break;;
    esac
  done

  echo "Do you wish to install iTerm2?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_iterm2; break;;
    No ) break;;
    esac
  done

  echo "Do you wish to install MacVim?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_macvim; break;;
    No ) break;;
    esac
  done

  [[ $? ]] \
  && _print_success "Software installs complete"
}

install_homebrew() {
  ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
  brew doctor
  [[ $? ]] \
  && _print_success "Installed Homebrew"
}

install_homebrew_cask() {
  brew tap caskroom/cask
  [[ $? ]] \
  && _print_success "Installed Homebrew Cask"
}

install_iterm2() {
  brew cask install iterm2
  [[ $? ]] \
  && _print_success "Installed iTerm2"
}

install_macvim() {
  brew cask install macvim
  [[ $? ]] \
  && _print_success "Installed and linked MacVim"
}

install_npm() {
  curl https://www.npmjs.org/install.sh | sh
  [[ $? ]] \
  && _print_success "Installed npm"
}

install_sketch() {
  brew cask install sketch
  [[ $? ]] \
  && _print_success "Installed Sketch"
}

install_xcode() {
  xcode-select --install
  [[ $? ]] \
  && _print_success "Installed xcode-select"
}

setup_vim() {
  # Force remove the vim directory if it's already there.
  _exists "${HOME}/.vim" \
  && rm -rf "${HOME}/.vim"

  ln -fs "${PROGDIR}/vim"                "${HOME}/.vim"
  ln -fs "${PROGDIR}/conf/runcom/vimrc"    "${HOME}/.vimrc"

  [[ $? ]] \
  && _print_success "ViM files symlinked"
}

update_vim_plugins() {
  vim +PluginInstall +PluginUpdate +qall
  [[ $? ]] \
  && _print_success "Updated ViM bundles"
}

setup_bash_files() {
  rm -rf "${HOME}/.bash_profile"
  rm -rf "${HOME}/.bash_helpers"
  rm -rf "${HOME}/.bashrc"
  rm -rf "${HOME}/.profile"

  ln -fs "${PROGDIR}/conf/bash/bashrc"          "${HOME}/.bashrc"
  ln -fs "${PROGDIR}/conf/bash/helpers"         "${HOME}/.bash_helpers"
  ln -fs "${PROGDIR}/conf/bash/bash_profile"    "${HOME}/.bash_profile"

  [[ $? ]] \
  && _print_success "bash files symlinked"
}

source_bash() {
  source "${HOME}/.bashrc"
  source "${HOME}/.bash_profile"
  [[ $? ]] \
  && _print_success "bash files sourced"
}

main() {
  _is_empty "$PROGDIR" \
  && error_out

  cmdline "$ARGS"

  echo "Do you want to go through the software install options?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) install_software; break;;
    No ) break;;
    esac
  done

  _require_prog brew "Homebrew is required to install formulae" http://brew.sh \
  && install_formulae

  _require_prog git "Git is required to use $PROGNAME" http://git-scm.com

  setup_vim
  setup_bash_files
  source_bash

  #setup_global_gitconfig

  echo "Do you wish to install and update ViM plugins?"
  select yn in "Yes" "No"; do
    case $yn in
    Yes ) update_vim_plugins; break;;
    No ) break;;
    esac
  done

  _print_success "All done!"
}

main
